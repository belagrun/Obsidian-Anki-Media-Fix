/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnkiMediaFixPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ANKI_PORT = 8765;
var DEFAULT_SETTINGS = {
  mediaFolder: "",
  batchSize: 50
};
var AnkiMediaFixPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "sync-all-media",
      name: "Sync all media to Anki (force)",
      callback: () => this.syncAllMedia()
    });
    this.addCommand({
      id: "sync-missing-media",
      name: "Sync only missing media to Anki",
      callback: () => this.syncMissingMedia()
    });
    this.addCommand({
      id: "list-missing-media",
      name: "List missing media in Anki",
      callback: () => this.listMissingMedia()
    });
    this.addSettingTab(new AnkiMediaFixSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Invocar API do AnkiConnect
  async invokeAnkiConnect(action, params = {}) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.addEventListener("error", () => reject("Failed to connect to Anki. Is Anki running with AnkiConnect?"));
      xhr.addEventListener("load", () => {
        try {
          const response = JSON.parse(xhr.responseText);
          if (response.error) {
            reject(response.error);
          } else {
            resolve(response.result);
          }
        } catch (e) {
          reject(e);
        }
      });
      xhr.open("POST", `http://127.0.0.1:${ANKI_PORT}`);
      xhr.send(JSON.stringify({ action, version: 6, params }));
    });
  }
  // Buscar todas as notas do Anki
  async getAllAnkiNotes() {
    const noteIds = await this.invokeAnkiConnect("findNotes", { query: "*" });
    if (noteIds.length === 0) {
      return [];
    }
    const notes = [];
    const batchSize = this.settings.batchSize;
    for (let i = 0; i < noteIds.length; i += batchSize) {
      const batch = noteIds.slice(i, i + batchSize);
      const batchNotes = await this.invokeAnkiConnect("notesInfo", { notes: batch });
      notes.push(...batchNotes);
    }
    return notes;
  }
  // Extrair nomes de arquivos de mídia dos campos das notas
  extractMediaFromNotes(notes) {
    const mediaFiles = /* @__PURE__ */ new Set();
    const imgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
    const soundRegex = /\[sound:([^\]]+)\]/gi;
    const mdImgRegex = /!\[[^\]]*\]\(([^)]+)\)/gi;
    for (const note of notes) {
      for (const fieldName in note.fields) {
        const fieldValue = note.fields[fieldName].value;
        let match;
        while ((match = imgRegex.exec(fieldValue)) !== null) {
          const filename = this.extractFilename(match[1]);
          if (filename && !this.isUrl(match[1])) {
            mediaFiles.add(decodeURIComponent(filename));
          }
        }
        imgRegex.lastIndex = 0;
        while ((match = soundRegex.exec(fieldValue)) !== null) {
          const filename = this.extractFilename(match[1]);
          if (filename) {
            mediaFiles.add(decodeURIComponent(filename));
          }
        }
        soundRegex.lastIndex = 0;
        while ((match = mdImgRegex.exec(fieldValue)) !== null) {
          const filename = this.extractFilename(match[1]);
          if (filename && !this.isUrl(match[1])) {
            mediaFiles.add(decodeURIComponent(filename));
          }
        }
        mdImgRegex.lastIndex = 0;
      }
    }
    return mediaFiles;
  }
  extractFilename(path) {
    const cleanPath = path.split("?")[0];
    const parts = cleanPath.split(/[/\\]/);
    return parts[parts.length - 1];
  }
  isUrl(path) {
    return path.startsWith("http://") || path.startsWith("https://") || path.startsWith("data:");
  }
  // Buscar lista de arquivos de mídia no Anki
  async getAnkiMediaFiles() {
    return await this.invokeAnkiConnect("getMediaFilesNames", { pattern: "*" });
  }
  // Encontrar arquivos no Obsidian vault
  async findFileInVault(filename) {
    const files = this.app.vault.getFiles();
    for (const file of files) {
      if (file.name === filename) {
        return file;
      }
    }
    const mediaFolders = ["attachments", "assets", "media", "images", "Anexos", "M\xEDdia"];
    if (this.settings.mediaFolder) {
      mediaFolders.unshift(this.settings.mediaFolder);
    }
    for (const folder of mediaFolders) {
      const path = `${folder}/${filename}`;
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian.TFile) {
        return file;
      }
    }
    return null;
  }
  // Enviar arquivo de mídia para o Anki
  async sendMediaToAnki(filename, filePath) {
    try {
      await this.invokeAnkiConnect("storeMediaFile", {
        filename,
        path: filePath,
        deleteExisting: true
      });
      return true;
    } catch (e) {
      console.error(`Failed to send ${filename}: ${e}`);
      return false;
    }
  }
  // Sincronizar todas as mídias (força reenvio)
  async syncAllMedia() {
    const notice = new import_obsidian.Notice("Scanning Anki notes for media...", 0);
    try {
      const notes = await this.getAllAnkiNotes();
      notice.setMessage(`Found ${notes.length} notes. Extracting media references...`);
      const mediaRefs = this.extractMediaFromNotes(notes);
      notice.setMessage(`Found ${mediaRefs.size} media references. Searching in vault...`);
      let sent = 0;
      let notFound = 0;
      const notFoundFiles = [];
      const adapter = this.app.vault.adapter;
      for (const filename of mediaRefs) {
        const file = await this.findFileInVault(filename);
        if (file) {
          const fullPath = adapter.getFullPath(file.path);
          const success = await this.sendMediaToAnki(filename, fullPath);
          if (success) {
            sent++;
            notice.setMessage(`Sent ${sent}/${mediaRefs.size} files...`);
          }
        } else {
          notFound++;
          notFoundFiles.push(filename);
        }
      }
      notice.hide();
      if (notFoundFiles.length > 0) {
        new ResultModal(this.app, sent, notFound, notFoundFiles).open();
      } else {
        new import_obsidian.Notice(`\u2705 Sync complete! Sent ${sent} files to Anki.`);
      }
    } catch (e) {
      notice.hide();
      new import_obsidian.Notice(`\u274C Error: ${e}`);
    }
  }
  // Sincronizar apenas mídias faltantes
  async syncMissingMedia() {
    const notice = new import_obsidian.Notice("Scanning Anki for missing media...", 0);
    try {
      const notes = await this.getAllAnkiNotes();
      notice.setMessage(`Found ${notes.length} notes. Extracting media references...`);
      const mediaRefs = this.extractMediaFromNotes(notes);
      notice.setMessage(`Found ${mediaRefs.size} media references. Checking existing files...`);
      const existingMedia = new Set(await this.getAnkiMediaFiles());
      const missingMedia = /* @__PURE__ */ new Set();
      for (const media of mediaRefs) {
        if (!existingMedia.has(media)) {
          missingMedia.add(media);
        }
      }
      notice.setMessage(`Found ${missingMedia.size} missing files. Sending to Anki...`);
      let sent = 0;
      let notFound = 0;
      const notFoundFiles = [];
      const adapter = this.app.vault.adapter;
      for (const filename of missingMedia) {
        const file = await this.findFileInVault(filename);
        if (file) {
          const fullPath = adapter.getFullPath(file.path);
          const success = await this.sendMediaToAnki(filename, fullPath);
          if (success) {
            sent++;
            notice.setMessage(`Sent ${sent}/${missingMedia.size} missing files...`);
          }
        } else {
          notFound++;
          notFoundFiles.push(filename);
        }
      }
      notice.hide();
      if (notFoundFiles.length > 0) {
        new ResultModal(this.app, sent, notFound, notFoundFiles).open();
      } else if (missingMedia.size === 0) {
        new import_obsidian.Notice(`\u2705 No missing media found!`);
      } else {
        new import_obsidian.Notice(`\u2705 Sync complete! Sent ${sent} missing files to Anki.`);
      }
    } catch (e) {
      notice.hide();
      new import_obsidian.Notice(`\u274C Error: ${e}`);
    }
  }
  // Listar mídias faltantes
  async listMissingMedia() {
    const notice = new import_obsidian.Notice("Scanning Anki for missing media...", 0);
    try {
      const notes = await this.getAllAnkiNotes();
      notice.setMessage(`Found ${notes.length} notes. Extracting media references...`);
      const mediaRefs = this.extractMediaFromNotes(notes);
      const existingMedia = new Set(await this.getAnkiMediaFiles());
      const missingMedia = [];
      for (const media of mediaRefs) {
        if (!existingMedia.has(media)) {
          missingMedia.push(media);
        }
      }
      notice.hide();
      new MissingMediaModal(this.app, missingMedia, this).open();
    } catch (e) {
      notice.hide();
      new import_obsidian.Notice(`\u274C Error: ${e}`);
    }
  }
};
var ResultModal = class extends import_obsidian.Modal {
  constructor(app, sent, notFound, notFoundFiles) {
    super(app);
    this.sent = sent;
    this.notFound = notFound;
    this.notFoundFiles = notFoundFiles;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Sync Results" });
    contentEl.createEl("p", { text: `\u2705 Sent: ${this.sent} files` });
    contentEl.createEl("p", { text: `\u26A0\uFE0F Not found in vault: ${this.notFound} files` });
    if (this.notFoundFiles.length > 0) {
      contentEl.createEl("h3", { text: "Files not found:" });
      const list = contentEl.createEl("div", { cls: "anki-media-fix-list" });
      list.style.maxHeight = "300px";
      list.style.overflow = "auto";
      list.style.fontSize = "12px";
      list.style.fontFamily = "monospace";
      list.style.backgroundColor = "var(--background-secondary)";
      list.style.padding = "10px";
      list.style.borderRadius = "5px";
      for (const file of this.notFoundFiles.slice(0, 100)) {
        list.createEl("div", { text: file });
      }
      if (this.notFoundFiles.length > 100) {
        list.createEl("div", { text: `... and ${this.notFoundFiles.length - 100} more` });
      }
    }
    const buttonDiv = contentEl.createEl("div", { cls: "anki-media-fix-buttons" });
    buttonDiv.style.marginTop = "20px";
    buttonDiv.style.textAlign = "right";
    const closeBtn = buttonDiv.createEl("button", { text: "Close" });
    closeBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var MissingMediaModal = class extends import_obsidian.Modal {
  constructor(app, missingMedia, plugin) {
    super(app);
    this.missingMedia = missingMedia;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Missing Media in Anki" });
    contentEl.createEl("p", { text: `Found ${this.missingMedia.length} missing files` });
    if (this.missingMedia.length > 0) {
      const list = contentEl.createEl("div", { cls: "anki-media-fix-list" });
      list.style.maxHeight = "400px";
      list.style.overflow = "auto";
      list.style.fontSize = "12px";
      list.style.fontFamily = "monospace";
      list.style.backgroundColor = "var(--background-secondary)";
      list.style.padding = "10px";
      list.style.borderRadius = "5px";
      list.style.marginBottom = "20px";
      for (const file of this.missingMedia.slice(0, 200)) {
        list.createEl("div", { text: file });
      }
      if (this.missingMedia.length > 200) {
        list.createEl("div", { text: `... and ${this.missingMedia.length - 200} more` });
      }
    }
    const buttonDiv = contentEl.createEl("div", { cls: "anki-media-fix-buttons" });
    buttonDiv.style.display = "flex";
    buttonDiv.style.justifyContent = "flex-end";
    buttonDiv.style.gap = "10px";
    if (this.missingMedia.length > 0) {
      const syncBtn = buttonDiv.createEl("button", { text: "Sync Missing Files" });
      syncBtn.style.backgroundColor = "var(--interactive-accent)";
      syncBtn.style.color = "var(--text-on-accent)";
      syncBtn.addEventListener("click", async () => {
        this.close();
        await this.plugin.syncMissingMedia();
      });
    }
    const closeBtn = buttonDiv.createEl("button", { text: "Close" });
    closeBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AnkiMediaFixSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Anki Media Fix Settings" });
    new import_obsidian.Setting(containerEl).setName("Media folder").setDesc('Primary folder where your media files are stored (e.g., "attachments", "assets"). Leave empty to search entire vault.').addText((text) => text.setPlaceholder("attachments").setValue(this.plugin.settings.mediaFolder).onChange(async (value) => {
      this.plugin.settings.mediaFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Batch size").setDesc("Number of notes to process at once when querying Anki (lower = slower but more stable)").addText((text) => text.setPlaceholder("50").setValue(String(this.plugin.settings.batchSize)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.batchSize = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "How to use" });
    const instructions = containerEl.createEl("div");
    instructions.innerHTML = `
			<ol>
				<li>Make sure Anki is running with AnkiConnect addon installed</li>
				<li>Use <strong>Ctrl/Cmd + P</strong> to open command palette</li>
				<li>Search for "Anki Media Fix"</li>
				<li>Choose one of the commands:
					<ul>
						<li><strong>Sync all media</strong>: Resends ALL media files referenced in your Anki notes</li>
						<li><strong>Sync only missing media</strong>: Sends only files that are missing in Anki</li>
						<li><strong>List missing media</strong>: Shows which files are missing</li>
					</ul>
				</li>
			</ol>
		`;
  }
};
